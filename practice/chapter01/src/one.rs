fn one(){
//===============1.5.2 变量绑定与原生类型=======================
    //---------------(1) 变量绑定-----------------------
//    let a1 = 5;
//    let a2:i32 = 5;
//    assert_eq!(a1,a2);
//    let b:u32 = 5;
//    assert_eq!(a1,b)   //该句导致报错
    //---------------(2) 可变绑定------------------------
//    let mut a: f64 = 1.0;
//    let b = 2.0f32;
    //改变可变绑定
//    a = 0.2;
//    println!("{:?}",a);
    //该为不可变绑定
//    let a = 2.0;
//    a = 3.0;
    //----------------(3) let解构-------------------------
//    let (a,mut b):(bool,bool) = (true,false);
//    println!("a = {:?}, b = {:?}",a,b);
    //a不可变绑定
//    a = false;
    //可变绑定
//    b = true;
//    assert_eq!(a,b);
    //----------------(4) 原生类型
    //布尔类型
//    let a = true;
//    let b: bool = false;
    //char类型，单个Unicode字符，4个字节，单引号
//    let c = 'c';
    //数字类型，有符号整形（i8, i16, i32, i64, isize）无符号整数（u8, u16, u32, u64, usize）浮点数（f32, f64）
//    let x = 43;
    //字符串类型，双引号
//    let str = "adf";
    //数组，固定大小，元素为同种类型，[T;N]
    //引用数组且不需要拷贝，&[T]
//    let arr = [0, 1, 2, 3, 4];
//    let middle = &arr[1..4];  //包含1, 2, 3
//    println!("{}",arr[0]);
//    println!("{}",middle[0]);
    //元祖，固定大小的有序列表，每个元素都有自己的类型，通过解构或索引获取元素
    let tuple:(i32,&str) = (50,"hello");
    let (fifty,_) = tuple;
    let hello = tuple.1;
    println!("{}",fifty);
    println!("{}",hello)
    //指针，最底层是裸指针 *const T 和 *mut T
    //函数，函数类型变量实际上是一个函数指针
    //元类型 ()
}